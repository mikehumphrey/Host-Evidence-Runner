
function Redact-TemplateCsv {
<#
.SYNOPSIS
  Redacts sensitive identity columns in the AD CS template audit CSV.

.PARAMETER InputCsv
  Path to the original CSV generated by the audit script.

.PARAMETER OutputCsv
  Path for the redacted CSV.

.PARAMETER Mode
  Redaction mode: 'Remove' | 'Mask' | 'Hash' (default: 'Mask').

.PARAMETER Columns
  Columns to redact. If omitted, uses default sensitive columns.

.PARAMETER Salt
  Optional salt string used when Mode = 'Hash'. If omitted, a random salt is generated
  for this run (hashes remain consistent within one run).
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)][string]$InputCsv,
        [Parameter(Mandatory=$true)][string]$OutputCsv,
        [ValidateSet('Remove','Mask','Hash')][string]$Mode = 'Mask',
        [string[]]$Columns = @(
            'FullControlGroups','ReadGroups','WriteGroups','EnrollGroups','AutoEnrollGroups',
            'FullControlSIDs','ReadSIDs','WriteSIDs','EnrollSIDs','AutoEnrollSIDs'
        ),
        [string]$Salt = $null
    )

    # Load rows
    if (-not (Test-Path -Path $InputCsv)) {
        throw "InputCsv not found: $InputCsv"
    }
    $rows = Import-Csv -Path $InputCsv

    if (-not $rows -or $rows.Count -eq 0) {
        throw "No rows found in CSV: $InputCsv"
    }

    # Build set of headers present
    $headers = $rows[0].PsObject.Properties.Name

    # Filter to only redact columns that actually exist
    $redactCols = @()
    foreach ($c in $Columns) { if ($headers -contains $c) { $redactCols += $c } }

    if ($redactCols.Count -eq 0) {
        Write-Warning "None of the requested columns were found. No changes made."
        $rows | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
        return
    }

    # Prepare hashing if requested
    $sha256 = $null
    if ($Mode -eq 'Hash') {
        $sha256 = [System.Security.Cryptography.SHA256]::Create()
        if (-not $Salt) {
            # Create a random salt for this run
            $Salt = [Guid]::NewGuid().ToString()
        }
        Write-Verbose "Using salt: $Salt"
        function Get-Hash {
            param([string]$text)
            if ([string]::IsNullOrWhiteSpace($text)) { return $null }
            $bytes = [System.Text.Encoding]::UTF8.GetBytes($Salt + '|' + $text)
            $hash  = $sha256.ComputeHash($bytes)
            # Hex string (shortened to 16 chars to keep CSV tidy)
            return ('{0}' -f (([BitConverter]::ToString($hash)).Replace('-','').ToLower())).Substring(0,16)
        }
    }

    # Helper: redact a semicolon-separated principal list
    function Redact-List {
        param(
            [string]$val,
            [string]$mode
        )
        if ([string]::IsNullOrWhiteSpace($val)) { return $val }

        # Split on ';', trim, drop empties
        $items = ($val -split ';') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

        switch ($mode) {
            'Remove' { return $null }
            'Mask'   { return (($items | ForEach-Object { 'REDACTED' }) -join '; ') }
            'Hash'   { return (($items | ForEach-Object { Get-Hash $_ }) -join '; ') }
            default  { return $val }
        }
    }

    # Apply redaction per row
    $redacted = foreach ($r in $rows) {
        # Clone to avoid mutating original
        $obj = [PSCustomObject]@{}
        foreach ($h in $headers) {
            $val = $r.$h
            if ($redactCols -contains $h) {
                switch ($Mode) {
                    'Remove' { $obj | Add-Member -NotePropertyName $h -NotePropertyValue $null }
                    default  { $obj | Add-Member -NotePropertyName $h -NotePropertyValue (Redact-List -val $val -mode $Mode) }
                }
            } else {
                $obj | Add-Member -NotePropertyName $h -NotePropertyValue $val
            }
        }
        $obj
    }

    # If Remove mode, drop columns entirely from the output header
    $final = $redacted
    if ($Mode -eq 'Remove') {
        $keepHeaders = @()
        foreach ($h in $headers) { if (-not ($redactCols -contains $h)) { $keepHeaders += $h } }
        # Project to the kept headers
        $final = $redacted | Select-Object -Property $keepHeaders
    }

    # Write output
    $outDir = Split-Path -Path $OutputCsv -Parent
    if ($outDir -and -not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir -Force | Out-Null }

    $final | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
    Write-Host ("Redacted CSV written: {0}" -f $OutputCsv) -ForegroundColor Green
}
